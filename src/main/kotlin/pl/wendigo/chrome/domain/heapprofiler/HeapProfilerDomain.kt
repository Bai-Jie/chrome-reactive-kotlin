package pl.wendigo.chrome.domain.heapprofiler

/**
 * HeapProfilerDomain represents remote debugger protocol domain.
 *
 * This class was autogenerated by main.go. Do not edit :)
 */
@pl.wendigo.chrome.ProtocolExperimental class HeapProfilerDomain internal constructor(private val connection : pl.wendigo.chrome.RemoteChromeConnection) {

	/**
	 *
	 */
	fun enable() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.enable", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun disable() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.disable", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun startTrackingHeapObjects(input : StartTrackingHeapObjectsRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.startTrackingHeapObjects", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun stopTrackingHeapObjects(input : StopTrackingHeapObjectsRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.stopTrackingHeapObjects", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun takeHeapSnapshot(input : TakeHeapSnapshotRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.takeHeapSnapshot", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun collectGarbage() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.collectGarbage", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun getObjectByHeapObjectId(input : GetObjectByHeapObjectIdRequest) : io.reactivex.Flowable<GetObjectByHeapObjectIdResponse> {
        return connection.runAndCaptureResponse("$domainName.getObjectByHeapObjectId", input, GetObjectByHeapObjectIdResponse::class.java)
	}

	/**
	 * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
	 */
	fun addInspectedHeapObject(input : AddInspectedHeapObjectRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.addInspectedHeapObject", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun getHeapObjectId(input : GetHeapObjectIdRequest) : io.reactivex.Flowable<GetHeapObjectIdResponse> {
        return connection.runAndCaptureResponse("$domainName.getHeapObjectId", input, GetHeapObjectIdResponse::class.java)
	}

	/**
	 *
	 */
	fun startSampling(input : StartSamplingRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.startSampling", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun stopSampling() : io.reactivex.Flowable<StopSamplingResponse> {
        return connection.runAndCaptureResponse("$domainName.stopSampling", null, StopSamplingResponse::class.java)
	}

  /**
   *
   */
  fun onAddHeapSnapshotChunk() : io.reactivex.Flowable<AddHeapSnapshotChunkEvent> {
      return connection.captureEvents("$domainName.addHeapSnapshotChunk", AddHeapSnapshotChunkEvent::class.java)
  }

  /**
   *
   */
  fun onResetProfiles() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
      return connection.captureEvents("$domainName.resetProfiles", pl.wendigo.chrome.GenericResponse::class.java)
  }

  /**
   *
   */
  fun onReportHeapSnapshotProgress() : io.reactivex.Flowable<ReportHeapSnapshotProgressEvent> {
      return connection.captureEvents("$domainName.reportHeapSnapshotProgress", ReportHeapSnapshotProgressEvent::class.java)
  }

  /**
   * If heap objects tracking has been started then backend regulary sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
   */
  fun onLastSeenObjectId() : io.reactivex.Flowable<LastSeenObjectIdEvent> {
      return connection.captureEvents("$domainName.lastSeenObjectId", LastSeenObjectIdEvent::class.java)
  }

  /**
   * If heap objects tracking has been started then backend may send update for one or more fragments
   */
  fun onHeapStatsUpdate() : io.reactivex.Flowable<HeapStatsUpdateEvent> {
      return connection.captureEvents("$domainName.heapStatsUpdate", HeapStatsUpdateEvent::class.java)
  }

  companion object {
    private const val domainName = "HeapProfiler"
  }
}

data class StartTrackingHeapObjectsRequest (
    /**
     *
     */
    val trackAllocations : Boolean? = null

)

data class StopTrackingHeapObjectsRequest (
    /**
     * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
     */
    val reportProgress : Boolean? = null

)

data class TakeHeapSnapshotRequest (
    /**
     * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
     */
    val reportProgress : Boolean? = null

)

data class GetObjectByHeapObjectIdRequest (
    /**
     *
     */
    val objectId : HeapSnapshotObjectId,

    /**
     * Symbolic group name that can be used to release multiple objects.
     */
    val objectGroup : String? = null

)

data class GetObjectByHeapObjectIdResponse (
  /**
   * Evaluation result.
   */
  val result : pl.wendigo.chrome.domain.runtime.RemoteObject

)

data class AddInspectedHeapObjectRequest (
    /**
     * Heap snapshot object id to be accessible by means of $x command line API.
     */
    val heapObjectId : HeapSnapshotObjectId

)

data class GetHeapObjectIdRequest (
    /**
     * Identifier of the object to get heap object id for.
     */
    val objectId : pl.wendigo.chrome.domain.runtime.RemoteObjectId

)

data class GetHeapObjectIdResponse (
  /**
   * Id of the heap snapshot object corresponding to the passed remote object id.
   */
  val heapSnapshotObjectId : HeapSnapshotObjectId

)

data class StartSamplingRequest (
    /**
     * Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
     */
    val samplingInterval : Double? = null

)

data class StopSamplingResponse (
  /**
   * Recorded sampling heap profile.
   */
  val profile : SamplingHeapProfile

)

data class AddHeapSnapshotChunkEvent (
  /**
   *
   */
  val chunk : String

)

data class ReportHeapSnapshotProgressEvent (
  /**
   *
   */
  val done : Int,

  /**
   *
   */
  val total : Int,

  /**
   *
   */
  val finished : Boolean? = null

)

data class LastSeenObjectIdEvent (
  /**
   *
   */
  val lastSeenObjectId : Int,

  /**
   *
   */
  val timestamp : Double

)

data class HeapStatsUpdateEvent (
  /**
   * An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.
   */
  val statsUpdate : Array<Int>

)

