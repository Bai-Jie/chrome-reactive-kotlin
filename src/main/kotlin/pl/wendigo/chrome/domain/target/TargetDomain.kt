package pl.wendigo.chrome.domain.target

/**
 * Supports additional targets discovery and allows to attach to them.
 *
 * This class was autogenerated by main.go. Do not edit :)
 */
@pl.wendigo.chrome.ProtocolExperimental class TargetDomain internal constructor(private val connection : pl.wendigo.chrome.RemoteChromeConnection) {

	/**
	 * Controls whether to discover available targets and notify via <code>targetCreated/targetDestroyed</code> events.
	 */
	fun setDiscoverTargets(input : SetDiscoverTargetsRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setDiscoverTargets", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.
	 */
	fun setAutoAttach(input : SetAutoAttachRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setAutoAttach", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 *
	 */
	fun setAttachToFrames(input : SetAttachToFramesRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setAttachToFrames", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Enables target discovery for the specified locations, when <code>setDiscoverTargets</code> was set to <code>true</code>.
	 */
	fun setRemoteLocations(input : SetRemoteLocationsRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setRemoteLocations", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Sends protocol message to the target with given id.
	 */
	fun sendMessageToTarget(input : SendMessageToTargetRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.sendMessageToTarget", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Returns information about a target.
	 */
	fun getTargetInfo(input : GetTargetInfoRequest) : io.reactivex.Flowable<GetTargetInfoResponse> {
        return connection.runAndCaptureResponse("$domainName.getTargetInfo", input, GetTargetInfoResponse::class.java)
	}

	/**
	 * Activates (focuses) the target.
	 */
	fun activateTarget(input : ActivateTargetRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.activateTarget", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Closes the target. If the target is a page that gets closed too.
	 */
	fun closeTarget(input : CloseTargetRequest) : io.reactivex.Flowable<CloseTargetResponse> {
        return connection.runAndCaptureResponse("$domainName.closeTarget", input, CloseTargetResponse::class.java)
	}

	/**
	 * Attaches to the target with given id.
	 */
	fun attachToTarget(input : AttachToTargetRequest) : io.reactivex.Flowable<AttachToTargetResponse> {
        return connection.runAndCaptureResponse("$domainName.attachToTarget", input, AttachToTargetResponse::class.java)
	}

	/**
	 * Detaches from the target with given id.
	 */
	fun detachFromTarget(input : DetachFromTargetRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.detachFromTarget", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.
	 */
	fun createBrowserContext() : io.reactivex.Flowable<CreateBrowserContextResponse> {
        return connection.runAndCaptureResponse("$domainName.createBrowserContext", null, CreateBrowserContextResponse::class.java)
	}

	/**
	 * Deletes a BrowserContext, will fail of any open page uses it.
	 */
	fun disposeBrowserContext(input : DisposeBrowserContextRequest) : io.reactivex.Flowable<DisposeBrowserContextResponse> {
        return connection.runAndCaptureResponse("$domainName.disposeBrowserContext", input, DisposeBrowserContextResponse::class.java)
	}

	/**
	 * Creates a new page.
	 */
	fun createTarget(input : CreateTargetRequest) : io.reactivex.Flowable<CreateTargetResponse> {
        return connection.runAndCaptureResponse("$domainName.createTarget", input, CreateTargetResponse::class.java)
	}

	/**
	 * Retrieves a list of available targets.
	 */
	fun getTargets() : io.reactivex.Flowable<GetTargetsResponse> {
        return connection.runAndCaptureResponse("$domainName.getTargets", null, GetTargetsResponse::class.java)
	}

  /**
   * Issued when a possible inspection target is created.
   */
  fun onTargetCreated() : io.reactivex.Flowable<TargetCreatedEvent> {
      return connection.captureEvents("$domainName.targetCreated", TargetCreatedEvent::class.java)
  }

  /**
   * Issued when a target is destroyed.
   */
  fun onTargetDestroyed() : io.reactivex.Flowable<TargetDestroyedEvent> {
      return connection.captureEvents("$domainName.targetDestroyed", TargetDestroyedEvent::class.java)
  }

  /**
   * Issued when attached to target because of auto-attach or <code>attachToTarget</code> command.
   */
  fun onAttachedToTarget() : io.reactivex.Flowable<AttachedToTargetEvent> {
      return connection.captureEvents("$domainName.attachedToTarget", AttachedToTargetEvent::class.java)
  }

  /**
   * Issued when detached from target for any reason (including <code>detachFromTarget</code> command).
   */
  fun onDetachedFromTarget() : io.reactivex.Flowable<DetachedFromTargetEvent> {
      return connection.captureEvents("$domainName.detachedFromTarget", DetachedFromTargetEvent::class.java)
  }

  /**
   * Notifies about new protocol message from attached target.
   */
  fun onReceivedMessageFromTarget() : io.reactivex.Flowable<ReceivedMessageFromTargetEvent> {
      return connection.captureEvents("$domainName.receivedMessageFromTarget", ReceivedMessageFromTargetEvent::class.java)
  }

  companion object {
    private const val domainName = "Target"
  }
}

data class SetDiscoverTargetsRequest (
    /**
     * Whether to discover available targets.
     */
    val discover : Boolean

)

data class SetAutoAttachRequest (
    /**
     * Whether to auto-attach to related targets.
     */
    val autoAttach : Boolean,

    /**
     * Whether to pause new targets when attaching to them. Use <code>Runtime.runIfWaitingForDebugger</code> to run paused targets.
     */
    val waitForDebuggerOnStart : Boolean

)

data class SetAttachToFramesRequest (
    /**
     * Whether to attach to frames.
     */
    val value : Boolean

)

data class SetRemoteLocationsRequest (
    /**
     * List of remote locations.
     */
    val locations : Array<RemoteLocation>

)

data class SendMessageToTargetRequest (
    /**
     *
     */
    val targetId : String,

    /**
     *
     */
    val message : String

)

data class GetTargetInfoRequest (
    /**
     *
     */
    val targetId : TargetID

)

data class GetTargetInfoResponse (
  /**
   *
   */
  val targetInfo : TargetInfo

)

data class ActivateTargetRequest (
    /**
     *
     */
    val targetId : TargetID

)

data class CloseTargetRequest (
    /**
     *
     */
    val targetId : TargetID

)

data class CloseTargetResponse (
  /**
   *
   */
  val success : Boolean

)

data class AttachToTargetRequest (
    /**
     *
     */
    val targetId : TargetID

)

data class AttachToTargetResponse (
  /**
   * Whether attach succeeded.
   */
  val success : Boolean

)

data class DetachFromTargetRequest (
    /**
     *
     */
    val targetId : TargetID

)

data class CreateBrowserContextResponse (
  /**
   * The id of the context created.
   */
  val browserContextId : BrowserContextID

)

data class DisposeBrowserContextRequest (
    /**
     *
     */
    val browserContextId : BrowserContextID

)

data class DisposeBrowserContextResponse (
  /**
   *
   */
  val success : Boolean

)

data class CreateTargetRequest (
    /**
     * The initial URL the page will be navigated to.
     */
    val url : String,

    /**
     * Frame width in DIP (headless chrome only).
     */
    val width : Int? = null,

    /**
     * Frame height in DIP (headless chrome only).
     */
    val height : Int? = null,

    /**
     * The browser context to create the page in (headless chrome only).
     */
    val browserContextId : BrowserContextID? = null

)

data class CreateTargetResponse (
  /**
   * The id of the page opened.
   */
  val targetId : TargetID

)

data class GetTargetsResponse (
  /**
   * The list of targets.
   */
  val targetInfos : Array<TargetInfo>

)

data class TargetCreatedEvent (
  /**
   *
   */
  val targetInfo : TargetInfo

)

data class TargetDestroyedEvent (
  /**
   *
   */
  val targetId : TargetID

)

data class AttachedToTargetEvent (
  /**
   *
   */
  val targetInfo : TargetInfo,

  /**
   *
   */
  val waitingForDebugger : Boolean

)

data class DetachedFromTargetEvent (
  /**
   *
   */
  val targetId : TargetID

)

data class ReceivedMessageFromTargetEvent (
  /**
   *
   */
  val targetId : TargetID,

  /**
   *
   */
  val message : String

)

