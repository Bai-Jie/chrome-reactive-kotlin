package pl.wendigo.chrome.domain.tracing

/**
 * TracingDomain represents remote debugger protocol domain.
 *
 * This class was autogenerated by main.go. Do not edit :)
 */
@pl.wendigo.chrome.ProtocolExperimental class TracingDomain internal constructor(private val connection : pl.wendigo.chrome.RemoteChromeConnection) {

	/**
	 * Start trace events collection.
	 */
	fun start(input : StartRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.start", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Stop trace events collection.
	 */
	fun end() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.end", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Gets supported tracing categories.
	 */
	fun getCategories() : io.reactivex.Flowable<GetCategoriesResponse> {
        return connection.runAndCaptureResponse("$domainName.getCategories", null, GetCategoriesResponse::class.java)
	}

	/**
	 * Request a global memory dump.
	 */
	fun requestMemoryDump() : io.reactivex.Flowable<RequestMemoryDumpResponse> {
        return connection.runAndCaptureResponse("$domainName.requestMemoryDump", null, RequestMemoryDumpResponse::class.java)
	}

	/**
	 * Record a clock sync marker in the trace.
	 */
	fun recordClockSyncMarker(input : RecordClockSyncMarkerRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.recordClockSyncMarker", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

  /**
   * Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event.
   */
  fun onDataCollected() : io.reactivex.Flowable<DataCollectedEvent> {
      return connection.captureEvents("$domainName.dataCollected", DataCollectedEvent::class.java)
  }

  /**
   * Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.
   */
  fun onTracingComplete() : io.reactivex.Flowable<TracingCompleteEvent> {
      return connection.captureEvents("$domainName.tracingComplete", TracingCompleteEvent::class.java)
  }

  /**
   *
   */
  fun onBufferUsage() : io.reactivex.Flowable<BufferUsageEvent> {
      return connection.captureEvents("$domainName.bufferUsage", BufferUsageEvent::class.java)
  }

  companion object {
    private const val domainName = "Tracing"
  }
}

data class StartRequest (
    /**
     * Category/tag filter
     */
    @pl.wendigo.chrome.ProtocolDeprecated val categories : String? = null,

    /**
     * Tracing options
     */
    @pl.wendigo.chrome.ProtocolDeprecated val options : String? = null,

    /**
     * If set, the agent will issue bufferUsage events at this interval, specified in milliseconds
     */
    val bufferUsageReportingInterval : Double? = null,

    /**
     * Whether to report trace events as series of dataCollected events or to save trace to a stream (defaults to <code>ReportEvents</code>).
     */
    val transferMode : String? = null,

    /**
     *
     */
    val traceConfig : TraceConfig? = null

)

data class GetCategoriesResponse (
  /**
   * A list of supported tracing categories.
   */
  val categories : Array<String>

)

data class RequestMemoryDumpResponse (
  /**
   * GUID of the resulting global memory dump.
   */
  val dumpGuid : String,

  /**
   * True iff the global memory dump succeeded.
   */
  val success : Boolean

)

data class RecordClockSyncMarkerRequest (
    /**
     * The ID of this clock sync marker
     */
    val syncId : String

)

data class DataCollectedEvent (
  /**
   *
   */
  val value : Array<Object>

)

data class TracingCompleteEvent (
  /**
   * A handle of the stream that holds resulting trace data.
   */
  val stream : pl.wendigo.chrome.domain.io.StreamHandle? = null

)

data class BufferUsageEvent (
  /**
   * A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
   */
  val percentFull : Double? = null,

  /**
   * An approximate number of events in the trace log.
   */
  val eventCount : Double? = null,

  /**
   * A number in range [0..1] that indicates the used size of event buffer as a fraction of its total size.
   */
  val value : Double? = null

)

