package pl.wendigo.chrome.domain.network

/**
 * Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.
 *
 * This class was autogenerated by main.go. Do not edit :)
 */
class NetworkDomain internal constructor(private val connection : pl.wendigo.chrome.RemoteChromeConnection) {

	/**
	 * Enables network tracking, network events will now be delivered to the client.
	 */
	fun enable(input : EnableRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.enable", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Disables network tracking, prevents network events from being sent to the client.
	 */
	fun disable() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.disable", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Allows overriding user agent with the given string.
	 */
	fun setUserAgentOverride(input : SetUserAgentOverrideRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setUserAgentOverride", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Specifies whether to always send extra HTTP headers with the requests from this page.
	 */
	fun setExtraHTTPHeaders(input : SetExtraHTTPHeadersRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setExtraHTTPHeaders", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Returns content served for the given request.
	 */
	fun getResponseBody(input : GetResponseBodyRequest) : io.reactivex.Flowable<GetResponseBodyResponse> {
        return connection.runAndCaptureResponse("$domainName.getResponseBody", input, GetResponseBodyResponse::class.java)
	}

	/**
	 * Blocks specific URL from loading.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun addBlockedURL(input : AddBlockedURLRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.addBlockedURL", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Cancels blocking of a specific URL from loading.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun removeBlockedURL(input : RemoveBlockedURLRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.removeBlockedURL", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun replayXHR(input : ReplayXHRRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.replayXHR", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Toggles monitoring of XMLHttpRequest. If <code>true</code>, console will receive messages upon each XHR issued.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun setMonitoringXHREnabled(input : SetMonitoringXHREnabledRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setMonitoringXHREnabled", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Tells whether clearing browser cache is supported.
	 */
	fun canClearBrowserCache() : io.reactivex.Flowable<CanClearBrowserCacheResponse> {
        return connection.runAndCaptureResponse("$domainName.canClearBrowserCache", null, CanClearBrowserCacheResponse::class.java)
	}

	/**
	 * Clears browser cache.
	 */
	fun clearBrowserCache() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.clearBrowserCache", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Tells whether clearing browser cookies is supported.
	 */
	fun canClearBrowserCookies() : io.reactivex.Flowable<CanClearBrowserCookiesResponse> {
        return connection.runAndCaptureResponse("$domainName.canClearBrowserCookies", null, CanClearBrowserCookiesResponse::class.java)
	}

	/**
	 * Clears browser cookies.
	 */
	fun clearBrowserCookies() : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.clearBrowserCookies", null, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun getCookies() : io.reactivex.Flowable<GetCookiesResponse> {
        return connection.runAndCaptureResponse("$domainName.getCookies", null, GetCookiesResponse::class.java)
	}

	/**
	 * Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the <code>cookies</code> field.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun getAllCookies() : io.reactivex.Flowable<GetAllCookiesResponse> {
        return connection.runAndCaptureResponse("$domainName.getAllCookies", null, GetAllCookiesResponse::class.java)
	}

	/**
	 * Deletes browser cookie with given name, domain and path.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun deleteCookie(input : DeleteCookieRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.deleteCookie", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun setCookie(input : SetCookieRequest) : io.reactivex.Flowable<SetCookieResponse> {
        return connection.runAndCaptureResponse("$domainName.setCookie", input, SetCookieResponse::class.java)
	}

	/**
	 * Tells whether emulation of network conditions is supported.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun canEmulateNetworkConditions() : io.reactivex.Flowable<CanEmulateNetworkConditionsResponse> {
        return connection.runAndCaptureResponse("$domainName.canEmulateNetworkConditions", null, CanEmulateNetworkConditionsResponse::class.java)
	}

	/**
	 * Activates emulation of network conditions.
	 */
	fun emulateNetworkConditions(input : EmulateNetworkConditionsRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.emulateNetworkConditions", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Toggles ignoring cache for each request. If <code>true</code>, cache will not be used.
	 */
	fun setCacheDisabled(input : SetCacheDisabledRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setCacheDisabled", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Toggles ignoring of service worker for each request.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun setBypassServiceWorker(input : SetBypassServiceWorkerRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setBypassServiceWorker", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * For testing.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun setDataSizeLimitsForTest(input : SetDataSizeLimitsForTestRequest) : io.reactivex.Flowable<pl.wendigo.chrome.GenericResponse> {
        return connection.runAndCaptureResponse("$domainName.setDataSizeLimitsForTest", input, pl.wendigo.chrome.GenericResponse::class.java)
	}

	/**
	 * Returns the DER-encoded certificate.
	 */
	@pl.wendigo.chrome.ProtocolExperimental fun getCertificate(input : GetCertificateRequest) : io.reactivex.Flowable<GetCertificateResponse> {
        return connection.runAndCaptureResponse("$domainName.getCertificate", input, GetCertificateResponse::class.java)
	}

  /**
   * Fired when resource loading priority is changed
   */
  fun onResourceChangedPriority() : io.reactivex.Flowable<ResourceChangedPriorityEvent> {
      return connection.captureEvents("$domainName.resourceChangedPriority", ResourceChangedPriorityEvent::class.java)
  }

  /**
   * Fired when page is about to send HTTP request.
   */
  fun onRequestWillBeSent() : io.reactivex.Flowable<RequestWillBeSentEvent> {
      return connection.captureEvents("$domainName.requestWillBeSent", RequestWillBeSentEvent::class.java)
  }

  /**
   * Fired if request ended up loading from cache.
   */
  fun onRequestServedFromCache() : io.reactivex.Flowable<RequestServedFromCacheEvent> {
      return connection.captureEvents("$domainName.requestServedFromCache", RequestServedFromCacheEvent::class.java)
  }

  /**
   * Fired when HTTP response is available.
   */
  fun onResponseReceived() : io.reactivex.Flowable<ResponseReceivedEvent> {
      return connection.captureEvents("$domainName.responseReceived", ResponseReceivedEvent::class.java)
  }

  /**
   * Fired when data chunk was received over the network.
   */
  fun onDataReceived() : io.reactivex.Flowable<DataReceivedEvent> {
      return connection.captureEvents("$domainName.dataReceived", DataReceivedEvent::class.java)
  }

  /**
   * Fired when HTTP request has finished loading.
   */
  fun onLoadingFinished() : io.reactivex.Flowable<LoadingFinishedEvent> {
      return connection.captureEvents("$domainName.loadingFinished", LoadingFinishedEvent::class.java)
  }

  /**
   * Fired when HTTP request has failed to load.
   */
  fun onLoadingFailed() : io.reactivex.Flowable<LoadingFailedEvent> {
      return connection.captureEvents("$domainName.loadingFailed", LoadingFailedEvent::class.java)
  }

  /**
   * Fired when WebSocket is about to initiate handshake.
   */
  fun onWebSocketWillSendHandshakeRequest() : io.reactivex.Flowable<WebSocketWillSendHandshakeRequestEvent> {
      return connection.captureEvents("$domainName.webSocketWillSendHandshakeRequest", WebSocketWillSendHandshakeRequestEvent::class.java)
  }

  /**
   * Fired when WebSocket handshake response becomes available.
   */
  fun onWebSocketHandshakeResponseReceived() : io.reactivex.Flowable<WebSocketHandshakeResponseReceivedEvent> {
      return connection.captureEvents("$domainName.webSocketHandshakeResponseReceived", WebSocketHandshakeResponseReceivedEvent::class.java)
  }

  /**
   * Fired upon WebSocket creation.
   */
  fun onWebSocketCreated() : io.reactivex.Flowable<WebSocketCreatedEvent> {
      return connection.captureEvents("$domainName.webSocketCreated", WebSocketCreatedEvent::class.java)
  }

  /**
   * Fired when WebSocket is closed.
   */
  fun onWebSocketClosed() : io.reactivex.Flowable<WebSocketClosedEvent> {
      return connection.captureEvents("$domainName.webSocketClosed", WebSocketClosedEvent::class.java)
  }

  /**
   * Fired when WebSocket frame is received.
   */
  fun onWebSocketFrameReceived() : io.reactivex.Flowable<WebSocketFrameReceivedEvent> {
      return connection.captureEvents("$domainName.webSocketFrameReceived", WebSocketFrameReceivedEvent::class.java)
  }

  /**
   * Fired when WebSocket frame error occurs.
   */
  fun onWebSocketFrameError() : io.reactivex.Flowable<WebSocketFrameErrorEvent> {
      return connection.captureEvents("$domainName.webSocketFrameError", WebSocketFrameErrorEvent::class.java)
  }

  /**
   * Fired when WebSocket frame is sent.
   */
  fun onWebSocketFrameSent() : io.reactivex.Flowable<WebSocketFrameSentEvent> {
      return connection.captureEvents("$domainName.webSocketFrameSent", WebSocketFrameSentEvent::class.java)
  }

  /**
   * Fired when EventSource message is received.
   */
  fun onEventSourceMessageReceived() : io.reactivex.Flowable<EventSourceMessageReceivedEvent> {
      return connection.captureEvents("$domainName.eventSourceMessageReceived", EventSourceMessageReceivedEvent::class.java)
  }

  companion object {
    private const val domainName = "Network"
  }
}

data class EnableRequest (
    /**
     * Buffer size in bytes to use when preserving network payloads (XHRs, etc).
     */
    @pl.wendigo.chrome.ProtocolExperimental val maxTotalBufferSize : Int? = null,

    /**
     * Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc).
     */
    @pl.wendigo.chrome.ProtocolExperimental val maxResourceBufferSize : Int? = null

)

data class SetUserAgentOverrideRequest (
    /**
     * User agent to use.
     */
    val userAgent : String

)

data class SetExtraHTTPHeadersRequest (
    /**
     * Map with extra HTTP headers.
     */
    val headers : Headers

)

data class GetResponseBodyRequest (
    /**
     * Identifier of the network request to get content for.
     */
    val requestId : RequestId

)

data class GetResponseBodyResponse (
  /**
   * Response body.
   */
  val body : String,

  /**
   * True, if content was sent as base64.
   */
  val base64Encoded : Boolean

)

data class AddBlockedURLRequest (
    /**
     * URL to block.
     */
    val url : String

)

data class RemoveBlockedURLRequest (
    /**
     * URL to stop blocking.
     */
    val url : String

)

data class ReplayXHRRequest (
    /**
     * Identifier of XHR to replay.
     */
    val requestId : RequestId

)

data class SetMonitoringXHREnabledRequest (
    /**
     * Monitoring enabled state.
     */
    val enabled : Boolean

)

data class CanClearBrowserCacheResponse (
  /**
   * True if browser cache can be cleared.
   */
  val result : Boolean

)

data class CanClearBrowserCookiesResponse (
  /**
   * True if browser cookies can be cleared.
   */
  val result : Boolean

)

data class GetCookiesResponse (
  /**
   * Array of cookie objects.
   */
  val cookies : Array<Cookie>

)

data class GetAllCookiesResponse (
  /**
   * Array of cookie objects.
   */
  val cookies : Array<Cookie>

)

data class DeleteCookieRequest (
    /**
     * Name of the cookie to remove.
     */
    val cookieName : String,

    /**
     * URL to match cooke domain and path.
     */
    val url : String

)

data class SetCookieRequest (
    /**
     * The request-URI to associate with the setting of the cookie. This value can affect the default domain and path values of the created cookie.
     */
    val url : String,

    /**
     * The name of the cookie.
     */
    val name : String,

    /**
     * The value of the cookie.
     */
    val value : String,

    /**
     * If omitted, the cookie becomes a host-only cookie.
     */
    val domain : String? = null,

    /**
     * Defaults to the path portion of the url parameter.
     */
    val path : String? = null,

    /**
     * Defaults ot false.
     */
    val secure : Boolean? = null,

    /**
     * Defaults to false.
     */
    val httpOnly : Boolean? = null,

    /**
     * Defaults to browser default behavior.
     */
    val sameSite : CookieSameSite? = null,

    /**
     * If omitted, the cookie becomes a session cookie.
     */
    val expirationDate : Timestamp? = null

)

data class SetCookieResponse (
  /**
   * True if successfully set cookie.
   */
  val success : Boolean

)

data class CanEmulateNetworkConditionsResponse (
  /**
   * True if emulation of network conditions is supported.
   */
  val result : Boolean

)

data class EmulateNetworkConditionsRequest (
    /**
     * True to emulate internet disconnection.
     */
    val offline : Boolean,

    /**
     * Additional latency (ms).
     */
    val latency : Double,

    /**
     * Maximal aggregated download throughput.
     */
    val downloadThroughput : Double,

    /**
     * Maximal aggregated upload throughput.
     */
    val uploadThroughput : Double,

    /**
     * Connection type if known.
     */
    val connectionType : ConnectionType? = null

)

data class SetCacheDisabledRequest (
    /**
     * Cache disabled state.
     */
    val cacheDisabled : Boolean

)

data class SetBypassServiceWorkerRequest (
    /**
     * Bypass service worker and load from network.
     */
    val bypass : Boolean

)

data class SetDataSizeLimitsForTestRequest (
    /**
     * Maximum total buffer size.
     */
    val maxTotalSize : Int,

    /**
     * Maximum per-resource size.
     */
    val maxResourceSize : Int

)

data class GetCertificateRequest (
    /**
     * Origin to get certificate for.
     */
    val origin : String

)

data class GetCertificateResponse (
  /**
   *
   */
  val tableNames : Array<String>

)

data class ResourceChangedPriorityEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * New priority
   */
  val newPriority : ResourcePriority,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp

)

data class RequestWillBeSentEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Frame identifier.
   */
  @pl.wendigo.chrome.ProtocolExperimental val frameId : pl.wendigo.chrome.domain.page.FrameId,

  /**
   * Loader identifier.
   */
  val loaderId : LoaderId,

  /**
   * URL of the document this request is loaded for.
   */
  val documentURL : String,

  /**
   * Request data.
   */
  val request : Request,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * UTC Timestamp.
   */
  @pl.wendigo.chrome.ProtocolExperimental val wallTime : Timestamp,

  /**
   * Request initiator.
   */
  val initiator : Initiator,

  /**
   * Redirect response data.
   */
  val redirectResponse : Response? = null,

  /**
   * Type of this resource.
   */
  @pl.wendigo.chrome.ProtocolExperimental val type : pl.wendigo.chrome.domain.page.ResourceType? = null

)

data class RequestServedFromCacheEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId

)

data class ResponseReceivedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Frame identifier.
   */
  @pl.wendigo.chrome.ProtocolExperimental val frameId : pl.wendigo.chrome.domain.page.FrameId,

  /**
   * Loader identifier.
   */
  val loaderId : LoaderId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * Resource type.
   */
  val type : pl.wendigo.chrome.domain.page.ResourceType,

  /**
   * Response data.
   */
  val response : Response

)

data class DataReceivedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * Data chunk length.
   */
  val dataLength : Int,

  /**
   * Actual bytes received (might be less than dataLength for compressed encodings).
   */
  val encodedDataLength : Int

)

data class LoadingFinishedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * Total number of bytes received for this request.
   */
  val encodedDataLength : Double

)

data class LoadingFailedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * Resource type.
   */
  val type : pl.wendigo.chrome.domain.page.ResourceType,

  /**
   * User friendly error message.
   */
  val errorText : String,

  /**
   * True if loading was canceled.
   */
  val canceled : Boolean? = null,

  /**
   * The reason why loading was blocked, if any.
   */
  @pl.wendigo.chrome.ProtocolExperimental val blockedReason : BlockedReason? = null

)

data class WebSocketWillSendHandshakeRequestEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * UTC Timestamp.
   */
  @pl.wendigo.chrome.ProtocolExperimental val wallTime : Timestamp,

  /**
   * WebSocket request data.
   */
  val request : WebSocketRequest

)

data class WebSocketHandshakeResponseReceivedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * WebSocket response data.
   */
  val response : WebSocketResponse

)

data class WebSocketCreatedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * WebSocket request URL.
   */
  val url : String,

  /**
   * Request initiator.
   */
  val initiator : Initiator? = null

)

data class WebSocketClosedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp

)

data class WebSocketFrameReceivedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * WebSocket response data.
   */
  val response : WebSocketFrame

)

data class WebSocketFrameErrorEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * WebSocket frame error message.
   */
  val errorMessage : String

)

data class WebSocketFrameSentEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * WebSocket response data.
   */
  val response : WebSocketFrame

)

data class EventSourceMessageReceivedEvent (
  /**
   * Request identifier.
   */
  val requestId : RequestId,

  /**
   * Timestamp.
   */
  val timestamp : Timestamp,

  /**
   * Message type.
   */
  val eventName : String,

  /**
   * Message identifier.
   */
  val eventId : String,

  /**
   * Message content.
   */
  val data : String

)

