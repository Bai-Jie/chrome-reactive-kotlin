package pl.wendigo.chrome
import io.reactivex.BackpressureStrategy
import io.reactivex.Flowable
import io.reactivex.Observable
import io.reactivex.schedulers.Schedulers
import io.reactivex.subjects.ReplaySubject
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong

internal class RemoteDebuggerConnection constructor(
    private val url: String,
    private val client: OkHttpClient,
    private val mapper: FrameMapper
) : WebSocketListener() {

    private var remoteConnection: WebSocket? = null

    private val messages: ReplaySubject<ResponseFrame> = ReplaySubject.create(128)
    private val eventNameToClassMapping: ConcurrentHashMap<String, Class<out ProtocolEvent>> = ConcurrentHashMap()
    private val nextRequestId = AtomicLong(0)

    internal fun connect(): RemoteDebuggerConnection {
        val wsRequest = Request.Builder().url(url).build()

        remoteConnection = client.newWebSocket(wsRequest, this)

        return this
    }

    internal fun registerEventMappings(mapOf: Map<String, Class<out ProtocolEvent>>) {
        eventNameToClassMapping.putAll(mapOf)
    }

    /**
     * Closes connection to debugger
     */
    internal fun close() {
        try {
            client.connectionPool().evictAll()
            client.dispatcher().executorService().shutdown()
            remoteConnection!!.close(1000, "Goodbye!")
            messages.onComplete()
        } catch (e : Exception) {
            messages.onError(e)
        }
    }

    /**
     * Sends request and captures response.
     */
    internal fun <T> runAndCaptureResponse(name: String, params: Any?, outClazz: Class<T>) : Flowable<T> {
        if (remoteConnection == null) {
            throw NotConnected("Remote connection to debugger was not established")
        }

        val request = RequestFrame(
            id = nextRequestId.incrementAndGet(),
            method = name,
            params = params
        )

        return Observable.just(request).flatMap {
            mapper.serialize(request)
        }.map { frame ->
            remoteConnection!!.send(frame)
        }.toFlowable(BackpressureStrategy.BUFFER).flatMap { result ->
            if (result == true) {
                messages
                    .filter { (frameId) -> frameId == request.id }
                    .take(1)
                    .flatMap { mapper.deserializeResponse(it, outClazz) }
                    .subscribeOn(Schedulers.io())
                    .toFlowable(BackpressureStrategy.BUFFER)
            } else {
                Flowable.error(RequestFailed("Could not enqueue message"))
            }
        }
    }

    /**
     * Captures events by given name and casts received messages to specified class.
     */
    internal fun <T> captureEvents(name : String, outClazz: Class<T>) : Flowable<T> where T : ProtocolEvent {
        return this.captureAllEvents().filter { event -> event.name() == name }.ofType(outClazz)
    }

    /**
     * Captures all events as generated by remote debugger
     */
    internal fun captureAllEvents() : Flowable<ProtocolEvent> {
        return messages
            .filter(ResponseFrame::isEvent)
            .flatMap { frame -> mapper.deserializeEvent(frame, eventNameToClassMapping[frame.method] ?: ProtocolEvent::class.java) }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.LATEST)
    }

    override fun onMessage(webSocket: WebSocket?, text: String?) {
        messages.onNext(mapper.deserialize(text!!, ResponseFrame::class.java))
    }

    override fun onClosed(webSocket: WebSocket?, code: Int, reason: String?) {
        messages.onComplete()
    }

    override fun onFailure(webSocket: WebSocket?, t: Throwable?, response: Response?) {
        messages.onComplete()
    }

    companion object {
        /**
         * Opens new RemoteDebuggerConnection session for given websocket uri.
         */
        @JvmStatic
        fun openSession(url: String) : RemoteDebuggerConnection {
            return RemoteDebuggerConnection(
                    url,
                    OkHttpClient.Builder().readTimeout(0, TimeUnit.MILLISECONDS).build(),
                    FrameMapper()
            )
        }
    }
}