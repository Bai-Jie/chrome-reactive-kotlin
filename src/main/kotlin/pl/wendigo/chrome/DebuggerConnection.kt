package pl.wendigo.chrome
import io.reactivex.BackpressureStrategy
import io.reactivex.Flowable
import io.reactivex.schedulers.Schedulers
import io.reactivex.subjects.ReplaySubject
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong

internal class DebuggerConnection constructor(
    private val url: String
) : WebSocketListener() {

    private val messages: ReplaySubject<ResponseFrame> = ReplaySubject.create(128)
    private val client: OkHttpClient = OkHttpClient.Builder().readTimeout(0, TimeUnit.MILLISECONDS).build()
    private val mappings: ConcurrentHashMap<String, Class<out DebuggerEvent>> = ConcurrentHashMap()
    private val nextCommandId = AtomicLong(0)
    private var remoteConnection: WebSocket? = null

    @Throws(RemoteChromeException::class)
    internal fun connect(): DebuggerConnection {
        val wsRequest = Request.Builder().url(url).build()

        remoteConnection = client.newWebSocket(wsRequest, this)

        return this
    }

    internal fun registerMappings(mapOf: Map<String, Class<out DebuggerEvent>>) {
        mappings.putAll(mapOf)
    }

    /**
     * Closes connection to debugger
     */
    internal fun close() {
        try {
            client.connectionPool().evictAll()
            client.dispatcher().executorService().shutdown()
            remoteConnection!!.close(1000, "Goodbye!")
            messages.onComplete()
        } catch (e : Exception) {
            messages.onError(e)
        }
    }

    /**
     * Sends request and captures response.
     */
    internal fun <T> runAndCaptureResponse(name: String, params: Any?, outClazz: Class<T>) : Flowable<T> {
        val request = RequestFrame(
                id = nextCommandId.incrementAndGet(),
                method = name,
                params = params
        )

        try {
            if (!remoteConnection!!.send(FrameMapper.serialize(request))) {
                return Flowable.error(RemoteChromeException("Could not enqueue message"))
            }
        } catch (ex: Exception) {
            return Flowable.error(RemoteChromeException("Could not enqueue message", ex))
        }

        return messages
            .filter { it.id == request.id }
            .take(1)
            .flatMap { FrameMapper.deserializeResponse(it, outClazz) }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.BUFFER)
    }

    /**
     * Captures events by given name and casts received messages to specified class.
     */
    internal fun <T> captureEvents(name : String, outClazz: Class<T>) : Flowable<T> where T : DebuggerEvent {
        return this.captureAllEvents().filter{
            it.name() == name
        }.ofType(outClazz)
    }

    /**
     * Captures all events as generated by remote debugger
     */
    internal fun captureAllEvents() : Flowable<DebuggerEvent> {
        return messages
            .filter(ResponseFrame::isEvent)
            .flatMap { frame -> FrameMapper.deserializeEvent(frame, mappings[frame.method] ?: DebuggerEvent::class.java) }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.LATEST)
    }

    override fun onMessage(webSocket: WebSocket?, text: String?) {
        messages.onNext(FrameMapper.deserialize(text!!, ResponseFrame::class.java))
    }

    override fun onClosed(webSocket: WebSocket?, code: Int, reason: String?) {
        messages.onComplete()
    }

    override fun onFailure(webSocket: WebSocket?, t: Throwable?, response: Response?) {
        messages.onComplete()
    }
}