package pl.wendigo.chrome
import io.reactivex.BackpressureStrategy
import io.reactivex.Flowable
import io.reactivex.schedulers.Schedulers
import io.reactivex.subjects.ReplaySubject
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import okhttp3.WebSocket
import okhttp3.WebSocketListener
import org.slf4j.LoggerFactory
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong

internal class RemoteChromeConnection constructor(
    private val debuggerUrl: String
) : WebSocketListener() {

    private val messages: ReplaySubject<ResponseFrame> = ReplaySubject.create(128)
    private val client: OkHttpClient = OkHttpClient.Builder().readTimeout(0, TimeUnit.MILLISECONDS).build()
    private val mappings: ConcurrentHashMap<String, Class<out ChromeProtocolEvent>> = ConcurrentHashMap()
    private val nextCommandId = AtomicLong(0)
    private var remoteConnection: WebSocket? = null

    @Throws(RemoteChromeException::class)
    internal fun connect(): RemoteChromeConnection {
        val wsRequest = Request.Builder()
                .url(debuggerUrl)
                .build()

        remoteConnection = client.newWebSocket(wsRequest, this)

        return this
    }

    internal fun registerMappings(mapOf: Map<String, Class<out ChromeProtocolEvent>>) {
        mappings.putAll(mapOf)
    }

    /**
     * Closes connection to debugger
     */
    internal fun close() {
        messages.onComplete()

        try {
            client.connectionPool().evictAll()
            client.dispatcher().executorService().shutdown()
            remoteConnection!!.close(1000, "Goodbye!")
        } catch (e : Exception) {
            logger.error("Could not close websocket {}", e)
        }
    }

    /**
     * Sends request and captures response.
     */
    fun <T> runAndCaptureResponse(name: String, params: Any?, outClazz: Class<T>) : Flowable<T> {
        val request = RequestFrame(
                id = nextCommandId.incrementAndGet(),
                method = name,
                params = params
        )

        try {
            if (!remoteConnection!!.send(FrameMapper.serialize(request))) {
                return Flowable.error(RemoteChromeException("Could not enqueue message"))
            }
        } catch (ex: Exception) {
            return Flowable.error(RemoteChromeException("Could not enqueue message", ex))
        }

        return messages
            .filter { it.id == request.id }
            .take(1)
            .flatMap { FrameMapper.deserializeResponse(it, outClazz) }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.BUFFER)
    }

    /**
     * Captures events by given name and casts received messages to specified class.
     */
    fun <T> captureEvents(outClazz: Class<T>) : Flowable<T> where T : ChromeProtocolEvent {
        return this.captureAllEvents().ofType(outClazz)
    }

    /**
     * Captures all events as generated by remote debugger
     */
    fun captureAllEvents() : Flowable<ChromeProtocolEvent> {
        return messages
            .filter(ResponseFrame::isEvent)
            .flatMap { frame -> FrameMapper.deserializeEvent(frame, mappings[frame.method] ?: ChromeProtocolEvent::class.java) }
            .subscribeOn(Schedulers.io())
            .toFlowable(BackpressureStrategy.LATEST)
    }


    override fun onMessage(webSocket: WebSocket?, text: String?) {
        messages.onNext(FrameMapper.deserialize(text!!, ResponseFrame::class.java))
    }

    override fun onClosed(webSocket: WebSocket?, code: Int, reason: String?) {
        messages.onComplete()
    }

    override fun onFailure(webSocket: WebSocket?, t: Throwable?, response: Response?) {
        messages.onComplete()
    }

    companion object {
        private val logger = LoggerFactory.getLogger(RemoteChromeConnection::class.java)
    }
}